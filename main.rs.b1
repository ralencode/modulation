use poloto::build;
use rustfft::{num_complex::Complex, FftPlanner};

use std::f64::consts::PI;
use std::fmt::Display;
use std::fs;

fn plot_vector<T>(vector: &[T], timeline: &[f64], name: &str, x: &str, y: &str) -> String
where
    T: Into<f64> + Copy,
{
    let svg = poloto::header();

    poloto::frame()
        .with_tick_lines([true, true])
        .with_viewbox(svg.get_viewbox())
        .build()
        .data(
            poloto::plots!(build::plot(""))
                .line(timeline.iter().zip(vector.into_iter().map(|&x| x.into()))),
        )
        .build_and_label((name, x, y))
        .append_to(poloto::header().dark_theme())
        .render_string()
        .expect("Could not build plot")
}

fn create_timeline(disc_freq: usize, duration: f64) -> Vec<f64> {
    let samples_count = (duration * disc_freq as f64) as i32;
    let freq = 1.0 / disc_freq as f64;
    (0..samples_count).map(|i| i as f64 * freq as f64).collect()
}

fn harmonic(freq: f64, timeline: &Vec<f64>) -> Vec<f64> {
    timeline
        .iter()
        .map(|&t| f64::sin(2.0 * PI * freq * t))
        .collect()
}

fn harmonic_to_meander(harmonic: &Vec<f64>) -> Vec<u8> {
    harmonic
        .iter()
        .map(|i| (if i > &0.0 { 1 } else { 0 }))
        .collect()
}

fn signal_spectrum<T>(signal: &Vec<T>) -> Vec<f64>
where
    T: Into<f64> + Copy + Display,
{
    let mut planner = FftPlanner::<f64>::new();
    let fft = planner.plan_fft_forward(signal.len());

    let mut buffer: Vec<Complex<f64>> = signal
        .into_iter()
        .map(|&x| Complex::new(x.into(), 0.0))
        .collect();
    fft.process(&mut buffer);

    buffer
        .iter()
        .take(signal.len() / 2)
        .map(|c| c.norm())
        .collect()
}

fn modified_signum(x: f64) -> f64 {
    if x <= 0.0 {
        0.0
    } else {
        1.0
    }
}

fn compute_signal_spectrum(signal_values: &[f64]) -> Vec<f64> {
    let mut spectrum = fft(signal_values);
    spectrum.iter_mut().for_each(|x| *x = x.abs());
    spectrum.iter().map(|x| *x * 2.0).collect()
}

fn square_signal_function_value(frequency: f64, t: f64) -> f64 {
    modified_signum(f64::sin(2.0 * PI * frequency * t))
}

fn harmonic_signal_function_value(frequency: f64, t: f64) -> f64 {
    f64::sin(2.0 * PI * frequency * t)
}

fn fft(signal: &[f64]) -> Vec<f64> {
    let mut planner = FftPlanner::<f64>::new();
    let fft = planner.plan_fft_forward(signal.len());

    let mut buffer: Vec<Complex<f64>> = signal.iter().map(|&x| Complex::new(x, 0.0)).collect();
    fft.process(&mut buffer);

    buffer.iter().map(|c| c.norm()).collect()
}

fn ifft(signal: &Vec<f64>) -> Vec<f64> {
    let mut planner = FftPlanner::<f64>::new();
    let fft = planner.plan_fft_inverse(signal.len());

    let mut buffer: Vec<Complex<f64>> = signal.iter().map(|&x| Complex::new(x, 0.0)).collect();
    fft.process(&mut buffer);

    buffer.iter().map(|c| c.re).collect()
}

fn add_noise(spectrum: &mut [f64]) {
    for el in spectrum {
        if *el < 0.2 {
            *el = 0.0;
        }
    }
}
/*
fn compute_signal_values(
    frequency: f64,
    duration: f64,
    discr_freq: f64,
    signal_type: &str,
) -> (Vec<f64>, Vec<f64>) {
    let t: Vec<f64> = create_timeline(discr_freq as usize, duration);
    let mut signal_values = vec![0.0; discr_freq as usize];
    match signal_type {
        "Square" => {
            for (i, el) in t.iter().enumerate() {
                signal_values[i] = if (el * frequency) % 1.0 < 0.5 {
                    1.0
                } else {
                    0.0
                };
            }
        }
        "Harmonic" => {
            for (i, el) in t.iter().enumerate() {
                signal_values[i] = (*el * 2.0 * PI * frequency).sin();
            }
        }
        _ => panic!("Invalid signal type"),
    }
    (t, signal_values)
}
*/
fn compute_signal_values(
    frequency: f64,
    duration: f64,
    discr_freq: f64,
    signal_type: &str,
) -> (Vec<f64>, Vec<f64>) {
    let t: Vec<f64> = (0..discr_freq as usize)
        .map(|i| i as f64 / discr_freq)
        .collect();
    let mut signal_values = vec![0.0; discr_freq as usize];
    match signal_type {
        "Square" => {
            for (i, el) in t.iter().enumerate() {
                signal_values[i] = modified_signum(*el * 2.0 * std::f64::consts::PI * frequency);
            }
        }
        "Harmonic" => {
            for (i, el) in t.iter().enumerate() {
                signal_values[i] = (*el * 2.0 * std::f64::consts::PI * frequency).sin();
            }
        }
        _ => panic!("Invalid signal type"),
    }
    (t, signal_values)
}

fn amplitude_modulation(
    modulated_signal_values: &[f64],
    carrier_signal_values: &[f64],
    discr_freq: f64,
) -> Vec<f64> {
    let m = 0.9;
    let mut res = vec![0.0; carrier_signal_values.len()];
    for (i, el) in carrier_signal_values.iter().enumerate() {
        let amp = if (i as f64 / discr_freq) % 1.0 < 0.5 {
            2.0
        } else {
            1.0
        };
        res[i] = *el
            * (1.0
                + m * modulated_signal_values[i]
                    / modulated_signal_values
                        .iter()
                        .fold(f64::INFINITY, |a, &b| a.max(b)));
        res[i] *= amp;
    }
    res
}

fn frequency_modulation(
    modulating_signal_values: &[f64],
    carrier_signal_freq: f64,
    t: &[f64],
    discr_freq: f64,
) -> Vec<f64> {
    let mut res = vec![0.0; t.len()];
    for (i, &time) in t.iter().enumerate() {
        let deviation = 2.0
            * PI
            * carrier_signal_freq
            * (modulating_signal_values
                .iter()
                .take_while(|&x| *x <= time)
                .sum::<f64>()
                / discr_freq);
        res[i] = (2.0 * PI * carrier_signal_freq * time + deviation).sin();
    }
    res
}

fn phase_modulation(
    modulating_signal_values: &[f64],
    carrier_signal_freq: f64,
    t: &[f64],
) -> Vec<f64> {
    let mut res = vec![0.0; t.len()];
    for (i, &time) in t.iter().enumerate() {
        res[i] = (2.0 * PI * carrier_signal_freq * time + modulating_signal_values[i]).sin();
    }
    res
}

fn main() {
    let amplitude = 1.0;
    let duration = 5.0;
    let mod_signal_freq = 1.0;
    let carrier_signal_freq = 10.0;
    let discr_freq = 900.0;

    let (t1, modulating_signal_values) =
        compute_signal_values(mod_signal_freq, duration, discr_freq, "Square");
    let (t2, carrier_signal_values) =
        compute_signal_values(carrier_signal_freq, duration, discr_freq, "Harmonic");
    let t3 = &t2;

    // Figure 1
    let fig1_dir = format!("output/fig1");
    fs::create_dir_all(&fig1_dir).expect("Cannot create fig1 directory");
    fs::write(
        format!("{}/modulating_signal.svg", fig1_dir),
        plot_vector(
            &modulating_signal_values,
            &t1,
            "Modulating Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/carrier_signal.svg", fig1_dir),
        plot_vector(
            &carrier_signal_values,
            &t2,
            "Carrier Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    // Figure 2
    let modulated_signal = amplitude_modulation(
        &modulating_signal_values,
        &carrier_signal_values,
        discr_freq,
    );
    let modulated_spectrum_values = compute_signal_spectrum(&modulated_signal);
    let freqs: Vec<f64> = (0..discr_freq as usize)
        .map(|i| i as f64 / discr_freq)
        .collect();

    let fig2_dir = format!("output/fig2");
    fs::create_dir_all(&fig2_dir).expect("Cannot create fig2 directory");
    fs::write(
        format!("{}/amplitude_modulated_signal.svg", fig2_dir),
        plot_vector(
            &modulated_signal,
            t3,
            "Amplitude Modulated Signal",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/amplitude_modulated_spectrum.svg", fig2_dir),
        plot_vector(
            &modulated_spectrum_values[..100],
            &freqs[..100],
            "Amplitude Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    let mut noisy_spectrum = modulated_spectrum_values.clone();
    add_noise(&mut noisy_spectrum);
    fs::write(
        format!("{}/noisy_spectrum.svg", fig2_dir),
        plot_vector(
            &noisy_spectrum[..100],
            &freqs[..100],
            "Noisy Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    let s_signal = ifft(&fft(&modulated_signal));
    let s_signal_abs: Vec<f64> = s_signal.iter().map(|x| x.abs()).collect();
    let s_signal_binary: Vec<u8> = s_signal_abs
        .iter()
        .map(|&x| if x <= 0.003 { 0 } else { 1 })
        .collect();

    fs::write(
        format!("{}/ifft_signal.svg", fig2_dir),
        plot_vector(
            &s_signal[..451],
            &t3[..451],
            "IFFT Signal",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/ifft_signal_abs.svg", fig2_dir),
        plot_vector(
            &s_signal_abs[..451],
            &t3[..451],
            "IFFT Signal Absolute",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/ifft_signal_binary.svg", fig2_dir),
        plot_vector(
            &s_signal_binary[..451],
            &t3[..451],
            "IFFT Signal Binary",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    let carrier_signal_values_fm = frequency_modulation(
        &modulating_signal_values,
        carrier_signal_freq,
        &t2,
        discr_freq,
    );
    let carrier_signal_spectre_fm = compute_signal_spectrum(&carrier_signal_values_fm);

    fs::write(
        format!("{}/frequency_modulated_signal.svg", fig2_dir),
        plot_vector(
            &carrier_signal_values_fm,
            &t2,
            "Frequency Modulated Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/frequency_modulated_spectrum.svg", fig2_dir),
        plot_vector(
            &carrier_signal_spectre_fm[..100],
            &freqs[..100],
            "Frequency Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    // Figure 3
    let fig3_dir = format!("output/fig3");
    fs::create_dir_all(&fig3_dir).expect("Cannot create fig3 directory");

    let carrier_signal_values_pm =
        phase_modulation(&modulating_signal_values, carrier_signal_freq, &t2);
    let carrier_signal_spectre_pm = compute_signal_spectrum(&carrier_signal_values_pm);

    fs::write(
        format!("{}/phase_modulated_signal.svg", fig3_dir),
        plot_vector(
            &carrier_signal_values_pm,
            &t2,
            "Phase Modulated Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/phase_modulated_spectrum.svg", fig3_dir),
        plot_vector(
            &carrier_signal_spectre_pm[..100],
            &freqs[..100],
            "Phase Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
    let carrier_signal_values_fm = frequency_modulation(
        &modulating_signal_values,
        carrier_signal_freq,
        &t2,
        discr_freq,
    );
    let carrier_signal_spectre_fm = compute_signal_spectrum(&carrier_signal_values_fm);

    fs::write(
        format!("{}/frequency_modulated_signal.svg", fig3_dir),
        plot_vector(
            &carrier_signal_values_fm,
            &t2,
            "Frequency Modulated Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");
    fs::write(
        format!("{}/frequency_modulated_spectrum.svg", fig3_dir),
        plot_vector(
            &carrier_signal_spectre_fm[..100],
            &freqs[..100],
            "Frequency Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
}
/*
fn main() {
    let amplitude = 1.0;
    let duration = 5.0;
    let mod_signal_freq = 1.0;
    let carrier_signal_freq = 10.0;
    let discr_freq = 900.0;

    let (t1, modulating_signal_values) =
        compute_signal_values(mod_signal_freq, duration, discr_freq, "Square");
    let (t2, carrier_signal_values) =
        compute_signal_values(carrier_signal_freq, duration, discr_freq, "Harmonic");
    let t3 = &t2;
    let modulated_signal = amplitude_modulation(&modulating_signal_values, &carrier_signal_values);

    let modulated_spectrum_values = compute_signal_spectrum(&modulated_signal);
    let freqs: Vec<f64> = (0..discr_freq as usize)
        .map(|i| i as f64 / discr_freq)
        .collect();

    let s_signal = ifft(&fft(&modulated_signal));
    let s_signal_abs = s_signal.iter().map(|x| x.abs()).collect::<Vec<f64>>();
    let s_signal_binary: Vec<u8> = s_signal_abs
        .iter()
        .map(|&x| if x <= 0.003 { 0 } else { 1 })
        .collect();

    let base_dir = "output";
    fs::create_dir_all(base_dir).expect("Cannot create output directory");

    // **Figure 1: Modulating and Carrier Signals (6 plots)**
    let fig1_dir = format!("{}/fig1", base_dir);
    fs::create_dir_all(&fig1_dir).expect("Cannot create fig1 directory");

    fs::write(
        format!("{}/modulating_signal.svg", fig1_dir),
        plot_vector(
            &modulating_signal_values,
            &t1,
            "Modulating Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/carrier_signal.svg", fig1_dir),
        plot_vector(
            &carrier_signal_values,
            &t2,
            "Carrier Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/modulated_signal.svg", fig1_dir),
        plot_vector(
            &modulated_signal,
            t3,
            "Amplitude Modulated Signal",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/modulated_spectrum.svg", fig1_dir),
        plot_vector(
            &modulated_spectrum_values[..100],
            &freqs[..100],
            "Amplitude Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    let mut noisy_spectrum = modulated_spectrum_values.clone();
    add_noise(&mut noisy_spectrum);
    fs::write(
        format!("{}/noisy_spectrum.svg", fig1_dir),
        plot_vector(
            &noisy_spectrum[..100],
            &freqs[..100],
            "Noisy Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/ifft_signal.svg", fig1_dir),
        plot_vector(
            &s_signal[..451],
            &t3[..451],
            "IFFT Signal",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    // **Figure 2: Further Processing (4 plots)**
    let fig2_dir = format!("{}/fig2", base_dir);
    fs::create_dir_all(&fig2_dir).expect("Cannot create fig2 directory");

    fs::write(
        format!("{}/ifft_signal_abs.svg", fig2_dir),
        plot_vector(
            &s_signal_abs[..451],
            &t3[..451],
            "IFFT Signal Absolute",
            "t, s",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/ifft_signal_binary.svg", fig2_dir),
        plot_vector(
            &s_signal_binary[..451],
            &t3[..451],
            "IFFT Signal Binary",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    let phi = 0.0;
    let carrier_signal_values_fm: Vec<f64> = t2
        .iter()
        .map(|&t| {
            (phi + 2.0 * PI * carrier_signal_freq * t
                + (modulating_signal_values
                    .iter()
                    .take_while(|i| **i < (t2.len() as f64))
                    .sum::<f64>()
                    / discr_freq)
                    / modulating_signal_values
                        .iter()
                        .fold(f64::INFINITY, |a, &b| a.max(b))
                    * 2.0
                    * PI
                    * carrier_signal_freq)
                .sin()
        })
        .collect();
    let carrier_signal_spectre_fm = signal_spectrum(&carrier_signal_values_fm);
    fs::write(
        format!("{}/frequency_modulated_signal.svg", fig2_dir),
        plot_vector(
            &carrier_signal_values_fm,
            &t2,
            "Frequency Modulated Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    fs::write(
        format!("{}/frequency_modulated_spectrum.svg", fig2_dir),
        plot_vector(
            &carrier_signal_spectre_fm[..100],
            &freqs[..100],
            "Frequency Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");

    // **Figure 3: Phase Modulation (2 plots)**
    let fig3_dir = format!("{}/fig3", base_dir);
    fs::create_dir_all(&fig3_dir).expect("Cannot create fig3 directory");

    let carrier_signal_values_pm: Vec<f64> = t2
        .iter()
        .map(|&t| {
            (2.0 * PI * carrier_signal_freq * t
                + modulating_signal_values.iter().map(|&x| x).sum::<f64>())
            .sin()
        })
        .collect();
    fs::write(
        format!("{}/phase_modulated_signal.svg", fig3_dir),
        plot_vector(
            &carrier_signal_values_pm,
            &t2,
            "Phase Modulated Signal",
            "t, s",
            "Values",
        ),
    )
    .expect("Unable to save file");

    let carrier_signal_spectre_pm = signal_spectrum(&carrier_signal_values_pm);
    fs::write(
        format!("{}/phase_modulated_spectrum.svg", fig3_dir),
        plot_vector(
            &carrier_signal_spectre_pm[..100],
            &freqs[..100],
            "Phase Modulated Spectrum",
            "Frequency, Hz",
            "Amplitude",
        ),
    )
    .expect("Unable to save file");
}
*/
/*
rewrite python code below as in rust code below. remove the code below after that.
fig, ax = plt.subplots(1, 2, figsize=(14, 6), layout='constrained')
ax[0].plot(t1, modulating_signal_values)
ax[0].set_xlabel('t, s')
ax[0].set_ylabel('Modulating values')
ax[1].plot(t2, carrier_signal_values)
ax[1].set_xlabel('t, s')
ax[1].set_ylabel('Carrier values')

fig1, ax1 = plt.subplots(2, 3, figsize=(14, 6), layout='constrained')
ax1[0, 0].plot(t3, modulated_signal)
ax1[0, 0].set_xlabel('t, s')
ax1[0, 0].set_ylabel('Amplitude modulation values')
freqs = np.linspace(0, discr_freq / duration, discr_freq)
ax1[0, 1].plot(freqs[:100], modulated_spectrum_values[:100])
ax1[0, 1].set_xlabel('frequency, Hz')
ax1[0, 1].set_ylabel('Amplitude')
signals.add_noise(modulated_spectrum_values)
ax1[0, 2].plot(freqs[:100], modulated_spectrum_values[:100])
s = np.real(ifft(modulated_spectrum_values))
ax1[1, 0].plot(t3[:451], s)
s = np.abs(hilbert(s))

ax1[1, 1].plot(t3[:451], s)
s = [0 if el <= 0.003 else 1 for el in s]
ax1[1, 2].plot(t3[:451], s)

fig2, ax2 = plt.subplots(2, 2, figsize=(14, 6), layout='constrained')
phi = 0
carrier_signal_values = np.sin(phi
                               + 2 * np.pi * carrier_signal_freq * t2
                               + np.array(list(sum(modulating_signal_values[:t]) / discr_freq for t in range(len(t2))))
                                    / max(modulating_signal_values) * 2 * np.pi * carrier_signal_freq)
ax2[0, 0].plot(t2, carrier_signal_values)
ax2[0, 0].set_xlabel('t, s')
ax2[0, 0].set_ylabel('Frequency modulated signal values')
carrier_signal_spectre = signals.compute_signal_spectrum(carrier_signal_values)
ax2[1, 0].plot(freqs[:100], carrier_signal_spectre[:100])
ax2[1, 0].set_xlabel('f, Hz')
ax2[1, 0].set_ylabel('Frequency modulated amplitude values')
carrier_signal_values = np.sin(2 * np.pi * carrier_signal_freq * t2 + modulating_signal_values)
ax2[0, 1].plot(t2, carrier_signal_values)
ax2[0, 1].set_xlabel('t, s')
ax2[0, 1].set_ylabel('Phase modulated signal values')
carrier_signal_spectre = signals.compute_signal_spectrum(carrier_signal_values)
ax2[1, 1].plot(freqs[:100], carrier_signal_spectre[:100])
ax2[1, 1].set_xlabel('f, Hz')
ax2[1, 1].set_ylabel('Phase modulated signal values')
plt.show()
*/
//rust code below is for reference only, i will remove it
/*
    let disc_freq = 500;
    let duration = 16.0;
    let freqs = [1.0, 2.0, 4.0, 8.0];
    for &freq in freqs.iter() {
        let suffix = format!("{}", freq as u8);
        let ext = ".svg";

        let dirname = &format!("out/freq{}/", suffix)[..];

        fs::create_dir_all(dirname).expect("Cannot create output directory");

        let harmonic_name = &format!("harmonic-freq{}", suffix)[..];
        let meander_name = &format!("meander-freq{}", suffix)[..];

        let duration = duration / freq;
        let timeline = create_timeline(disc_freq, duration);

        let length = timeline.len();
        let amplitudes = (0..length / 2)
            .map(|i| i as f64 * disc_freq as f64 / length as f64)
            .collect();

        let sine_graph = harmonic(freq, &timeline);
        let square_graph = harmonic_to_meander(&sine_graph);

        fs::write(
            format!("{}{}{}", dirname, harmonic_name, ext),
            plot_vector(
                &sine_graph,
                &timeline,
                "harmonic signal",
                "time",
                "amplitude",
            ),
        )
        .expect("Unable to save file result.svg");
        fs::write(
            format!("{}{}{}", dirname, meander_name, ext),
            plot_vector(
                &square_graph,
                &timeline,
                "meander signal",
                "time",
                "amplitude",
            ),
        )
        .expect("Unable to save file result.svg");

        let sine_spectrum = signal_spectrum(&sine_graph);
        let square_spectrum = signal_spectrum(&square_graph);

        fs::write(
            format!("{}{}-spectrum{}", dirname, harmonic_name, ext),
            plot_vector(
                &sine_spectrum,
                &amplitudes,
                "spectrum of harmonic signal",
                "frequency",
                "amplitude",
            ),
        )
        .expect("Unable to save file result.svg");
        fs::write(
            format!("{}{}-spectrum{}", dirname, meander_name, ext),
            plot_vector(
                &square_spectrum,
                &amplitudes,
                "spectrum of meander signal",
                "frequency",
                "amplitude",
            ),
        )
        .expect("Unable to save file result.svg");
    }
}
*/
